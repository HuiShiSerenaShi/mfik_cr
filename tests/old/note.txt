cudnn


下一步建议
参数优化：

当前的BETA_ZNN1=20和BETA_ZNN2=20是手动调试得来的，建议使用超参数搜索（如网格搜索）进一步优化。
稳定性测试：

在更复杂的轨迹或更长的轨迹上测试算法的稳定性，确保不会出现振荡或发散。
可视化优化：

可以加入更多的动态可视化，比如绘制机械臂在运动过程中的动画，进一步确认轨迹跟踪的精度和实时性。
加入噪声：

如果目标是验证系统的鲁棒性，可以在输入数据（如位置、速度）中加入一定的噪声，观察算法的表现。

算法：
1. 设置参数 如 Td delta_t 目标轨迹等
2.初始化一些数据 例如 关节角度 雅克比矩阵等
3.for k=0 : Td/delta_t do
4. 获取k时刻实际末端位置
5. znn1获取k时刻的 angle_dot
6. 通过离散方法计算K+1时刻需执行的关节角度
7. 计算k时刻末端实际速度和加速度
8. 计算k时刻关节实际加速度
9. znn2获取k时刻的 雅克比_dot
10. 通过离散方法计算k+1时刻的雅克比
11. 用第6步算得的k+1时刻的执行信号（关节角度）控制机器人移动。
12. end for  

从错误提示和视频描述来看，问题可能源于以下几个方面：

1. **数值计算的溢出（overflow encountered in matmul）：**
   - 在 `znn_control.py` 中，`jacobian.T @ jacobian` 的数值可能非常大，导致计算结果溢出。这种情况可能是由于雅可比矩阵的值不合理，比如数值远大于物理意义上的范围（例如，远远超过机械臂的尺度）。

2. **`sin` 和 `cos` 函数出现无效值（invalid value encountered in cos/sin）：**
   - 这种问题通常是由于传递给 `np.sin` 或 `np.cos` 的输入包含了非法值，比如 `nan` 或 `inf`。这可能源于前面某一步计算出现了错误，导致传递的角度值变成无效值。

### 为什么会出现这些问题？

1. **`H_mat` 和 `W_mat` 的计算问题：**
   如果 `jacobian` 矩阵本身有异常值（例如计算中出现了过大的值或溢出），那么矩阵乘法会导致结果进一步失控，产生 `nan` 或 `inf`。

2. **关节角度更新过程中的误差累积：**
   在 `znn_trajectory_tracking` 中，关节角度 `angles` 是通过离散积分更新的。如果 `angle_dot`（角速度）在某些情况下变得极大，可能会导致 `angles` 超出正常范围（如超过 ±10^6），进而使得 `np.sin` 和 `np.cos` 失效。

3. **数值不稳定性：**
   如果 `beta1` 或 `beta2` 的值不合理（过大或过小），或者轨迹追踪中的误差反馈项未被正确处理，可能会导致系统变得不稳定。

4. **初始条件的问题：**
   起始关节角度可能与轨迹的起始点不匹配，导致 ZNN 在初始阶段产生巨大的修正角速度 `angle_dot`。

### 如何解决这些问题？

1. **检查初始条件和轨迹：**
   - 确保 `initial_angles` 与轨迹起点的关节角度一致。
   - 使用 `forward_kinematics_two_link` 验证初始角度计算出的末端位置是否与轨迹起点匹配。

2. **限制角度更新范围：**
   - 在更新 `angles` 时，使用 `np.clip` 限制角度的范围，例如限制在 [0, 2π] 或其他合理范围内。

3. **添加数值检查：**
   - 在每一步计算中，检查 `jacobian` 和 `angle_dot` 是否包含 `nan` 或 `inf`。
   ```python
   if np.any(np.isnan(jacobian)) or np.any(np.isinf(jacobian)):
       raise ValueError("雅可比矩阵包含非法值！")
   ```

4. **调试参数：**
   - 降低 `beta1` 和 `beta2` 的值，减小系统对误差的敏感性。
   - 确保输入的 `dt` 值合理，避免过小导致数值误差累积。

5. **可视化问题：**
   - 调试时，可以在每一步打印关节角度 `angles` 和雅可比矩阵 `jacobian`，定位具体出错的步骤。

你可以根据这些建议调整代码和参数，然后重新运行测试。如果还有问题，可以提供更详细的运行日志，我可以进一步帮助分析。


正则化伪逆是通过引入一个正则化项来改进伪逆（pseudo-inverse）的稳定性，尤其是在雅可比矩阵接近奇异点或条件数（condition number）过大时使用。

---

### 什么是伪逆的问题？

在轨迹控制中，伪逆 \( J^+ = (J^T J)^{-1} J^T \) 用来解决非方阵雅可比矩阵下的关节速度计算问题。但是：

1. **雅可比矩阵接近奇异点时：**
   - 奇异点会导致 \( J^T J \) 矩阵的特征值接近零，从而使其不可逆或数值不稳定。
   - 这种情况下，伪逆计算会放大小的误差，导致结果变得极端不稳定。

2. **数值误差：**
   - 即使不在奇异点，当矩阵条件数（condition number，表示矩阵是否易受数值误差影响）很大时，伪逆计算也可能因为小的数值误差导致不准确。

---

### 正则化伪逆如何解决？

通过在伪逆公式中引入一个小的正则化项 \( \lambda \)，即使 \( J^T J \) 接近奇异或数值不稳定，也可以通过这个额外项使得计算更加稳定。

#### 正则化伪逆公式

普通伪逆公式：
\[
J^+ = (J^T J)^{-1} J^T
\]

正则化伪逆公式：
\[
J^+_\lambda = (J^T J + \lambda I)^{-1} J^T
\]
- 其中，\( \lambda > 0 \) 是一个正则化参数。
- \( I \) 是单位矩阵。

#### 关键点：
1. \( \lambda \) 的作用是“加权”矩阵 \( J^T J \)，避免其特征值过小导致的不可逆问题。
2. 正则化伪逆在接近奇异点时更稳定，因为它人为增加了矩阵 \( J^T J \) 的对角线元素，防止其接近零。

---

### 使用正则化伪逆的好处

1. **稳定性：** 
   - 在接近奇异点时，正则化项可以让伪逆计算更加稳定。
   - 避免了由于数值不稳定导致的追踪发散。

2. **鲁棒性：**
   - 正则化伪逆对噪声或误差更具鲁棒性，尤其是在控制任务中。

3. **收敛性：**
   - 在复杂轨迹或快速变化的情况下，正则化伪逆可以更好地适应并收敛。

---

### 如何在代码中实现？

在你的 ZNN 控制中，可以通过引入正则化伪逆代替普通的伪逆：

```python
def regularized_pseudo_inverse(J, lambda_reg=1e-4):
    """
    计算正则化伪逆矩阵。

    参数:
        J (np.ndarray): 雅可比矩阵。
        lambda_reg (float): 正则化参数。

    返回:
        np.ndarray: 正则化伪逆矩阵。
    """
    J_T = J.T
    identity = np.eye(J.shape[1])  # 单位矩阵
    regularized_matrix = J_T @ J + lambda_reg * identity
    pseudo_inverse = np.linalg.inv(regularized_matrix) @ J_T
    return pseudo_inverse
```

然后在 `znn_update` 中替换伪逆计算：

```python
J_pseudo = regularized_pseudo_inverse(J, lambda_reg=1e-4)
```

---

### 正则化参数 \( \lambda \) 的选择

- 通常，正则化参数 \( \lambda \) 的值需要根据任务场景调整。
- 太小：接近普通伪逆，可能在奇异点不稳定。
- 太大：对轨迹精度可能有轻微影响，但会显著提高稳定性。
- **推荐初值：** \( \lambda = 1e-4 \) 或 \( \lambda = 1e-3 \)。

---

### 何时需要正则化伪逆？

1. 如果你的追踪任务中包含了接近奇异点的情况（例如：末端位置接近两连杆的直线延伸方向）。
2. 如果发现普通伪逆计算时系统经常发散或抖动。
3. 如果任务中对数值稳定性要求较高（例如长时间复杂轨迹追踪）。

通过引入正则化伪逆，可以更安全地解决这些问题，特别是在双ZNN的实现中，这对提高雅可比估计的准确性和系统稳定性尤为重要。